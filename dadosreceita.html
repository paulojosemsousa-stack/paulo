<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Consulta CNPJ (corrigido) — Parser robusto + RateLimit</title>
  <style>
    body { font-family: Inter, system-ui, Arial; background:#f5f7fa; color:#222; padding:18px; }
    .card { max-width:920px; margin:18px auto; background:white; border-radius:10px; padding:18px; box-shadow:0 6px 18px rgba(10,20,40,0.06); }
    h1 { margin:0 0 8px 0; font-size:20px; }
    p.lead { margin:0 0 14px 0; color:#444; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:12px; }
    input[type=file] { display:block; }
    button { padding:10px 14px; border-radius:8px; border:none; background:#0b7cff; color:white; cursor:pointer; }
    button.secondary { background:#6c757d; }
    .progress { width:100%; height:14px; background:#e8eef8; border-radius:8px; overflow:hidden; margin-top:8px; }
    .progress > span { display:block; height:100%; background:#0b7cff; width:0%; transition:width .2s linear; }
    pre.log { background:#0f1724; color:#e6eefc; padding:10px; border-radius:6px; max-height:260px; overflow:auto; font-size:13px; }
    label { font-size:13px; color:#333; }
    .small { font-size:13px; color:#666; }
    .config { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .input { padding:8px 10px; border-radius:6px; border:1px solid #ddd; background:white; min-width:200px; }
    .link-download { display:inline-block; margin-top:10px; text-decoration:none; color:#0b7cff; font-weight:600; }
  </style>
  <!-- PapaParse CDN -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
  <div class="card">
    <h1>Consulta CNPJ — Parser robusto & rate-limit</h1>
    <p class="lead">Upload de CSV com coluna <strong>CNPJ</strong>. Corrige parser (papaparse), limpa CNPJs, tenta consultar API e gera CSV final. Se a API bloquear por CORS, o arquivo final ainda será gerado com mensagens de erro em <code>STATUS_API</code>.</p>

    <div class="row">
      <input id="fileInput" type="file" accept=".csv,text/csv" />
      <button id="btnParse">Ler & Limpar CNPJs</button>
      <button id="btnCleanExport" class="secondary">Exportar só CNPJs limpos</button>
    </div>

    <div class="row config">
      <label>API base (ex.: https://receitaws.com.br/v1/cnpj/)</label>
      <input id="apiBase" class="input" value="https://receitaws.com.br/v1/cnpj/" />
      <label>Chamadas/minuto</label>
      <input id="callsPerMinute" class="input" value="3" style="width:80px;" />
      <label>Timeout req (ms)</label>
      <input id="timeoutMs" class="input" value="10000" style="width:100px;" />
    </div>

    <div class="row">
      <button id="btnStart" style="min-width:180px">Iniciar consulta à API</button>
      <button id="btnAbort" class="secondary" disabled>Cancelar</button>
    </div>

    <div class="small">Progresso:</div>
    <div class="progress" aria-hidden="true"><span id="progressBar"></span></div>
    <div style="margin-top:8px;" id="status">Nenhuma ação iniciada.</div>

    <h3 style="margin-top:12px">Log</h3>
    <pre class="log" id="log"></pre>

    <a id="downloadLink" class="link-download" style="display:none" href="#">Download CSV final</a>
  </div>

<script>
(() => {
  // Utilitários
  const el = id => document.getElementById(id);
  const logEl = el('log'), statusEl = el('status'), pbar = el('progressBar'), downloadLink = el('downloadLink');
  const fileInput = el('fileInput'), btnParse = el('btnParse'), btnCleanExport = el('btnCleanExport');
  const btnStart = el('btnStart'), btnAbort = el('btnAbort');
  const apiBaseInput = el('apiBase'), callsPerMinuteInput = el('callsPerMinute'), timeoutMsInput = el('timeoutMs');

  let parsedRows = []; // array of objects from CSV
  let cleanedCnpjs = []; // array of {original, cnpj}
  let controllerAbort = null;
  let abortRequested = false;

  function addLog(txt) {
    const time = new Date().toLocaleTimeString();
    logEl.textContent = `${time} - ${txt}\n` + logEl.textContent;
  }

  function setStatus(txt, color) {
    statusEl.textContent = txt;
    statusEl.style.color = color || '#111';
  }

  function setProgress(percent) {
    pbar.style.width = percent + '%';
  }

  function cleanCnpj(raw) {
    if (raw === null || raw === undefined) return '';
    const only = String(raw).replace(/\D/g,'');
    return only === '' ? '' : only;
  }

  // Parse with PapaParse (robusto)
  btnParse.addEventListener('click', () => {
    const f = fileInput.files && fileInput.files[0];
    if (!f) { setStatus('Selecione um arquivo CSV primeiro.', 'crimson'); return; }
    addLog('Iniciando parse com PapaParse...');
    setStatus('Lendo CSV...', '#666');
    Papa.parse(f, {
      header: true,
      skipEmptyLines: true,
      dynamicTyping: false,
      complete: (results) => {
        parsedRows = results.data || [];
        addLog(`CSV carregado: ${parsedRows.length} linhas (cabecalho: ${JSON.stringify(results.meta.fields)})`);
        // localizar coluna CNPJ (case-insensitive)
        const headers = results.meta.fields.map(h => h.toUpperCase());
        const cnpjIndex = headers.indexOf('CNPJ');
        if (cnpjIndex === -1) {
          setStatus("Coluna 'CNPJ' não encontrada no CSV (procure coluna com nome 'CNPJ').", 'crimson');
          addLog("Erro: coluna CNPJ não encontrada.");
          return;
        }
        // build cleanedCnpjs list (respect original row)
        cleanedCnpjs = parsedRows.map((row, idx) => {
          // try to access by header named 'CNPJ' (case-insensitive)
          let raw = row['CNPJ'];
          if (raw === undefined) {
            // fallback: find first header named case-insensitively
            for (const k of Object.keys(row)) {
              if (k.toUpperCase() === 'CNPJ') { raw = row[k]; break; }
            }
          }
          const c = cleanCnpj(raw);
          return { index: idx, original: raw, cnpj: c };
        }).filter(x => x.cnpj); // remove empty
        addLog(`CNPJs limpos: ${cleanedCnpjs.length}`);
        setStatus(`CSV pronto. ${cleanedCnpjs.length} CNPJs encontrados e limpos.`, 'green');
      },
      error: (err) => {
        addLog('Erro parse: ' + err.message);
        setStatus('Erro lendo CSV: ' + err.message, 'crimson');
      }
    });
  });

  // Exporta só os cnpjs limpos (útil quando API não acessível)
  btnCleanExport.addEventListener('click', () => {
    if (cleanedCnpjs.length === 0) { setStatus('Nenhum CNPJ limpo disponível. Faça o parse primeiro.', 'crimson'); return; }
    const rows = cleanedCnpjs.map(x => ({ CNPJ: x.cnpj }));
    const csv = Papa.unparse(rows);
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    downloadLink.href = url;
    downloadLink.download = 'cnpjs_limpos.csv';
    downloadLink.style.display = 'inline-block';
    downloadLink.textContent = 'Download: cnpjs_limpos.csv';
    setStatus('Arquivo de CNPJs limpos gerado para download.', 'green');
    addLog('Export: cnpjs_limpos.csv pronto.');
  });

  // Função de fetch com timeout e tratamento simples
  async function fetchWithTimeout(url, options = {}, timeout = 10000) {
    const ctrl = new AbortController();
    const id = setTimeout(() => ctrl.abort(), timeout);
    try {
      const res = await fetch(url, { ...options, signal: ctrl.signal });
      clearTimeout(id);
      return res;
    } catch (err) {
      clearTimeout(id);
      throw err;
    }
  }

  // Iniciar consultas (rate-limited)
  btnStart.addEventListener('click', async () => {
    if (cleanedCnpjs.length === 0) { setStatus('Nenhum CNPJ limpo disponível. Faça o parse primeiro.', 'crimson'); return; }
    const apiBase = (apiBaseInput.value || '').trim();
    if (!apiBase) { setStatus('Informe a base da API.', 'crimson'); return; }
    const callsPerMinute = Math.max(1, parseInt(callsPerMinuteInput.value) || 3);
    const timeoutMs = Math.max(1000, parseInt(timeoutMsInput.value) || 10000);
    const intervalMs = Math.ceil(60000 / callsPerMinute);

    abortRequested = false;
    controllerAbort = new AbortController();
    btnAbort.disabled = false;
    btnStart.disabled = true;
    setStatus('Iniciando consultas... (veja log)', '#0b7cff');
    addLog(`Iniciando ${cleanedCnpjs.length} requisições — limite ${callsPerMinute} req/min => ${intervalMs}ms entre chamadas.`);

    const results = []; // resultados para CSV final
    let processed = 0;

    for (let i = 0; i < cleanedCnpjs.length; i++) {
      if (abortRequested) { addLog('Abort solicitado pelo usuário.'); break; }

      const item = cleanedCnpjs[i];
      const cnpj = item.cnpj;
      const url = apiBase.endsWith('/') ? apiBase + cnpj : apiBase + '/' + cnpj;

      // tentativa com backoff básico para 429: 3 tentativas com backoff exponencial
      let attempt = 0, maxAttempts = 3, got = null, errorMsg = null;
      while (attempt < maxAttempts && !got && !abortRequested) {
        try {
          attempt++;
          addLog(`(${i+1}/${cleanedCnpjs.length}) Requisitando ${cnpj} (tentativa ${attempt}) -> ${url}`);
          // fetch com timeout
          const response = await fetchWithTimeout(url, {}, timeoutMs);
          // se 200 -> parse
          if (response.ok) {
            const js = await response.json();
            // alguns endpoints usam { status: "ERROR", message: "..."} -> normalizar
            if (js && js.status && js.status.toUpperCase && js.status.toUpperCase() === 'ERROR') {
              errorMsg = js.message || 'API returned ERROR';
              addLog(`API respondeu ERROR para ${cnpj}: ${errorMsg}`);
              got = { raw: js, status: `ERRO_API: ${errorMsg}` };
            } else {
              got = { raw: js, status: 'OK' };
            }
          } else if (response.status === 429) {
            errorMsg = `HTTP 429`;
            addLog(`429 recebido para ${cnpj}. Backoff antes de nova tentativa.`);
            // backoff
            await new Promise(res => setTimeout(res, 1000 * attempt * 2));
          } else {
            errorMsg = `HTTP_${response.status}`;
            addLog(`Resposta HTTP ${response.status} para ${cnpj}`);
            got = { raw: null, status: `ERRO_HTTP_${response.status}` };
          }
        } catch (err) {
          // Erro: pode ser CORS, timeout, network
          const m = (err && err.name) ? err.name : (err && err.message) ? err.message : String(err);
          errorMsg = `ERRO_FETCH: ${m}`;
          addLog(`Erro fetch para ${cnpj}: ${m}`);
          // Se for AbortError, sair
          if (err.name === 'AbortError') {
            addLog('Fetch abortado via AbortController.');
            break;
          }
          // backoff curto antes de nova tentativa
          await new Promise(res => setTimeout(res, 800 * attempt));
        }
      } // while attempts

      // montar linha de resultado — manter campos consistentes
      const out = {
        CNPJ: cnpj,
        ORIGINAL_INDEX: item.index,
        ORIGINAL_RAW: item.original
      };

      if (got && got.raw) {
        // extrair campos comuns se existirem (adaptável)
        const data = got.raw;
        out.STATUS_API = got.status || 'OK';
        out.DATA_ABERTURA = data.abertura || data.data_abertura || '';
        out.RAZAO_SOCIAL = data.nome || data.razao_social || '';
        out.NOME_FANTASIA = data.fantasia || data.nome_fantasia || '';
        // QSA / socios pode estar em data.qsa (array) ou data.socios
        try {
          if (Array.isArray(data.qsa)) out.SOCIOS = data.qsa.map(s => s.nome || s).join(' | ');
          else if (Array.isArray(data.socios)) out.SOCIOS = data.socios.join(' | ');
          else out.SOCIOS = data.socios || '';
        } catch (e) { out.SOCIOS = ''; }
        out.UF = data.uf || data.estado || '';
        out.MUNICIPIO = data.municipio || data.municipio_nome || '';
        out.TELEFONE = data.telefone || '';
        out.EMAIL = data.email || '';
      } else {
        out.STATUS_API = errorMsg || 'ERRO_DESCONHECIDO';
      }

      results.push(out);
      processed++;
      const percent = Math.round((processed / cleanedCnpjs.length) * 100);
      setProgress(percent);
      setStatus(`Processados ${processed}/${cleanedCnpjs.length} — último: ${cnpj} — ${out.STATUS_API}`, '#0b7cff');

      // esperar intervalo entre chamadas
      if (i < cleanedCnpjs.length - 1) {
        await new Promise(res => setTimeout(res, intervalMs));
      }
    } // for each cnpj

    // fim
    btnAbort.disabled = true;
    btnStart.disabled = false;
    setProgress(100);
    setStatus('Processamento finalizado. Gerando CSV...', 'green');
    addLog('Gerando CSV final com Papa.unparse ...');

    // gerar CSV final com Papa.unparse (assegura quoting)
    const csv = Papa.unparse(results, { quotes: true });
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    downloadLink.href = url;
    downloadLink.download = 'resultado_cnpj_completo_web_corrigido.csv';
    downloadLink.style.display = 'inline-block';
    downloadLink.textContent = 'Download: resultado_cnpj_completo_web_corrigido.csv';
    addLog('CSV final pronto para download.');
    setStatus('Arquivo pronto. Clique em "Download".', 'green');
  });

  // Abort button
  btnAbort.addEventListener('click', () => {
    abortRequested = true;
    btnAbort.disabled = true;
    btnStart.disabled = false;
    setStatus('Abort solicitado. Aguardando término das operações em andamento...', 'orange');
    addLog('Usuário solicitou abort.');
  });

})();
</script>
</body>
</html>
